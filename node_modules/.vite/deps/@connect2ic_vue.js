import "./chunk-5V4XYVCG.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createCommentVNode,
  createElementBlock,
  defineComponent,
  inject,
  isRef,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  ref,
  renderList,
  renderSlot,
  shallowRef,
  unref,
  watch
} from "./chunk-PSTACYT2.js";
import {
  normalizeClass,
  toDisplayString
} from "./chunk-ABUW4KGX.js";
import "./chunk-S5KM4IGW.js";

// node_modules/@xstate/vue/es/useActor.js
function isActorWithState(actorRef) {
  return "state" in actorRef;
}
var noop = function() {
};
function defaultGetSnapshot(actorRef) {
  return "getSnapshot" in actorRef ? actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : void 0;
}
function useActor(actorRef, getSnapshot) {
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var actorRefRef = isRef(actorRef) ? actorRef : shallowRef(actorRef);
  var state = shallowRef(getSnapshot(actorRefRef.value));
  var send = function(event) {
    actorRefRef.value.send(event);
  };
  watch(actorRefRef, function(newActor, _2, onCleanup) {
    state.value = getSnapshot(newActor);
    var unsubscribe = newActor.subscribe({
      next: function(emitted) {
        return state.value = emitted;
      },
      error: noop,
      complete: noop
    }).unsubscribe;
    onCleanup(function() {
      return unsubscribe();
    });
  }, {
    immediate: true
  });
  return { state, send };
}

// node_modules/@xstate/vue/es/useSelector.js
var defaultCompare = function(a, b2) {
  return a === b2;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var selected = shallowRef(selector(getSnapshot(actor)));
  var updateSelectedIfChanged = function(nextSelected) {
    if (!compare(selected.value, nextSelected)) {
      selected.value = nextSelected;
    }
  };
  var sub;
  onMounted(function() {
    var initialSelected = selector(getSnapshot(actor));
    updateSelectedIfChanged(initialSelected);
    sub = actor.subscribe(function(emitted) {
      var nextSelected = selector(emitted);
      updateSelectedIfChanged(nextSelected);
    });
  });
  onBeforeUnmount(function() {
    sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  });
  return selected;
}

// node_modules/@connect2ic/vue/dist/connect2ic-vue.esm.js
var _ = Symbol();
function b() {
  return { ...inject(_).dialog };
}
function w() {
  const { client: n } = inject(_);
  return useSelector(n._service, (e) => e.context.providers);
}
var h = (c = {}) => {
  const { onConnect: i = () => {
  }, onDisconnect: s = () => {
  } } = c, { client: l } = inject(_), a = useSelector(l._service, (e) => e.context.principal), r = useSelector(l._service, (e) => e.context.activeProvider), u = useSelector(l._service, (e) => e.value.idle), { state: d } = useActor(l._service), v = computed(() => {
    var _a;
    return (_a = d.value.matches({ idle: "connected" })) != null ? _a : false;
  }), m = computed(() => {
    var _a;
    return (_a = d.value.matches({ idle: "initializing" })) != null ? _a : false;
  }), p = computed(() => {
    var _a;
    return (_a = d.value.matches({ idle: "connecting" })) != null ? _a : false;
  }), C = computed(() => {
    var _a;
    return (_a = d.value.matches({ idle: "disconnecting" })) != null ? _a : false;
  }), y = computed(() => {
    var _a;
    return (_a = d.value.matches({ idle: "idle" })) != null ? _a : false;
  });
  let g, b2;
  return onMounted(() => {
    g = l.on("connect", i), b2 = l.on("disconnect", s);
  }), onUnmounted(() => {
    g(), b2();
  }), { principal: a, status: u, activeProvider: r, isConnected: v, isConnecting: p, isDisconnecting: C, isInitializing: m, isIdle: y, connect: (e) => {
    l._service.send({ type: "CONNECT", data: { provider: e } });
  }, disconnect: () => {
    l._service.send({ type: "DISCONNECT" });
  } };
};
var D = () => {
  const { isConnected: e, activeProvider: t } = h(), o = computed(() => {
    var _a;
    return !!((_a = t.value) == null ? void 0 : _a.meta.features.includes("wallet"));
  });
  return [computed(() => e.value && o.value && t.value ? t.value : void 0), { loading: ref(true), error: ref(false) }];
};
var x = () => {
  const [e] = D(), n = ref(), t = ref(true), o = ref(), s = async () => {
    var _a;
    const n2 = e.value;
    if (!n2)
      return void (o.value = void 0);
    const c = await ((_a = n2.queryBalance) == null ? void 0 : _a.call(n2));
    return o.value = c, t.value = false, c;
  };
  return watch(e, (e2) => {
    s();
  }), [o, { loading: t, error: n, refetch: s }];
};
var I = ({ amount: e, to: n, from: t }) => {
  const [o] = D();
  h();
  const i = ref(true), s = ref();
  return [async () => {
    var _a;
    const t2 = o.value;
    if (!t2)
      return;
    i.value = true;
    const c = await ((_a = t2.requestTransfer) == null ? void 0 : _a.call(t2, { amount: e, to: n }).catch((e2) => {
      s.value = e2;
    }));
    return i.value = false, c;
  }, { loading: i, error: s }];
};
var P = (t, o = { mode: "auto" }) => {
  const { mode: i } = o, { client: s } = inject(_), l = useSelector(s._service, (e) => e.context.anonymousActors[t]), a = useSelector(s._service, (e) => e.context.actors[t]), { isConnected: r } = h(), u = computed(() => r.value && a.value && "anonymous" !== i ? a.value : l.value), d = computed(() => !u.value), v = ref(false);
  return [u, { error: v, loading: d }];
};
var B = defineComponent({ props: { dark: { type: Boolean, default: false }, style: { type: String, default: "" } }, emits: ["onConnect", "onDisconnect"], setup(e, { emit: n }) {
  const { open: t } = b();
  let { isConnected: o, disconnect: c } = h({ onConnect: () => {
    n("onConnect", {});
  }, onDisconnect: () => {
    n("onDisconnect", {});
  } });
  return (e2, n2) => (openBlock(), createElementBlock(Fragment, null, [unref(o) ? (openBlock(), createElementBlock("button", { key: 0, class: "connect-button", onClick: n2[0] || (n2[0] = () => unref(c)()) }, " Disconnect ")) : createCommentVNode("v-if", true), unref(o) ? createCommentVNode("v-if", true) : (openBlock(), createElementBlock("button", { key: 1, class: "connect-button", onClick: n2[1] || (n2[1] = () => unref(t)()) }, " Connect "))], 64));
} });
B.__file = "src/components/ConnectButton.vue";
var q = ["onClick"];
var E = ["src"];
var N = { class: "button-label" };
var O = defineComponent({ props: { dark: { type: Boolean, required: false } }, emits: ["onClose", "onClickInside"], setup(e, { emit: n }) {
  const { isOpen: c, close: s, open: y } = b(), g = w(), { connect: f } = h({ onConnect: () => {
    s();
  } });
  watch(c, (e2) => {
    e2 && (document.body.style.overflow = "hidden"), e2 || (document.body.style.overflow = "unset");
  });
  const k = () => {
    s(), n("onClose");
  }, _2 = (e2) => {
    e2.stopPropagation(), n("onClickInside");
  }, D2 = (e2) => {
    27 === e2.keyCode && s();
  };
  return onMounted(() => window.addEventListener("keydown", D2)), onUnmounted(() => window.removeEventListener("keydown", D2)), (n2, t) => unref(c) ? (openBlock(), createElementBlock("div", { key: 0, class: normalizeClass("dialog-styles " + (e.dark ? " dark" : " light")), onClick: k }, [createBaseVNode("div", { onClick: _2, class: "dialog-container" }, [createBaseVNode("div", null, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(g), (n3) => (openBlock(), createElementBlock("button", { key: n3.meta.id, onClick: () => unref(f)(n3.meta.id), class: normalizeClass(`button-styles ${n3.meta.id}-styles`) }, [createBaseVNode("img", { class: "img-styles", src: e.dark ? n3.meta.icon.dark : n3.meta.icon.light }, null, 8, E), createBaseVNode("div", null, [createBaseVNode("span", N, toDisplayString(n3.meta.name), 1)])], 10, q))), 128))])])], 2)) : createCommentVNode("v-if", true);
} });
O.__file = "src/components/ConnectDialog.vue";
var S = defineComponent({ props: { client: { type: null, required: true } }, setup(e) {
  const { client: n } = e;
  let t = ref(false);
  return provide(_, { dialog: { open: () => {
    t.value = true;
  }, close: () => {
    t.value = false;
  }, isOpen: t }, client: n }), (e2, n2) => renderSlot(e2.$slots, "default");
} });
S.__file = "src/Connect2ICProvider.vue";
export {
  S as Connect2ICProvider,
  B as ConnectButton,
  O as ConnectDialog,
  x as useBalance,
  P as useCanister,
  h as useConnect,
  b as useDialog,
  w as useProviders,
  I as useTransfer,
  D as useWallet
};
//# sourceMappingURL=@connect2ic_vue.js.map
